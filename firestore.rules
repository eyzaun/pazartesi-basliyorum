rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ========================================================================
    // Helper Functions
    // ========================================================================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Check if user is the owner
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Check if user exists in resource
    function isResourceOwner(resource) {
      return isAuthenticated() && request.auth.uid == resource.data.userId;
    }
    
    // Validate string field
    function isValidString(field, minLen, maxLen) {
      return field is string 
        && field.size() >= minLen 
        && field.size() <= maxLen;
    }
    
    // Validate email format
    function isValidEmail(email) {
      return email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$');
    }
    
    // Check if timestamp is recent (within 5 minutes)
    function isRecentTimestamp(ts) {
      return ts > request.time - duration.value(5, 'm');
    }
    
    // ========================================================================
    // Users Collection
    // ========================================================================
    
    match /users/{userId} {
      // Allow read if:
      // - User is authenticated and reading their own data, OR
      // - User profile is public, OR
      // - Checking username availability during signup (limited to username field only)
      allow read: if isAuthenticated() && (
        isOwner(userId) || 
        resource.data.privacy.profileVisibility == 'public'
      );
      
      // Allow list (query) for username uniqueness check during signup
      // This is safe because we only allow querying by username field
      allow list: if true;
      
      // Allow create if:
      // - User is authenticated
      // - Creating their own document
      // - Required fields are valid
      allow create: if isAuthenticated() 
        && isOwner(userId)
        && isValidString(request.resource.data.email, 3, 100)
        && isValidEmail(request.resource.data.email)
        && isValidString(request.resource.data.username, 3, 30)
        && isValidString(request.resource.data.displayName, 1, 50)
        && request.resource.data.stats.totalCompletions == 0
        && request.resource.data.stats.currentStreak == 0
        && request.resource.data.stats.longestStreak == 0;
      
      // Allow update if:
      // - User is authenticated and updating their own data
      // - Not changing userId or createdAt
      allow update: if isAuthenticated() 
        && isOwner(userId)
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.createdAt == resource.data.createdAt;
      
      // Never allow delete (soft delete via status instead)
      allow delete: if false;
    }
    
    // ========================================================================
    // Habits Collection
    // ========================================================================
    
    match /habits/{habitId} {
      // Allow read if:
      // - User is authenticated and is the owner, OR
      // - Habit is shared and user is in sharedWith array
      allow read: if isAuthenticated() && (
        request.auth.uid == resource.data.ownerId ||
        (resource.data.get('isShared', false) == true && request.auth.uid in resource.data.get('sharedWith', []))
      );
      
      // Allow list (queries) if authenticated
      // Query filters will ensure users only see their own habits
      allow list: if isAuthenticated();
      
      // Allow create if:
      // - User is authenticated
      // - User is the owner (using ownerId field from Firestore)
      // - Basic field validation (name and category must exist)
      allow create: if isAuthenticated()
        && request.auth.uid == request.resource.data.ownerId
        && request.resource.data.name is string
        && request.resource.data.category is string;
      
      // Allow update if:
      // - User is authenticated and is the owner
      // - Not changing habitId or ownerId
      allow update: if isAuthenticated()
        && request.auth.uid == resource.data.ownerId
        && request.resource.data.habitId == resource.data.habitId
        && request.resource.data.ownerId == resource.data.ownerId;
      
      // Allow delete if:
      // - User is authenticated and is the owner
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.ownerId;
    }
    
    // ========================================================================
    // Habit Logs Collection
    // ========================================================================
    
    match /habit_logs/{logId} {
      // Allow read if:
      // - User is authenticated and is the owner
      allow read: if isAuthenticated() && isResourceOwner(resource);
      
      // Allow list (queries) if authenticated
      // Query filters will ensure users only see their own logs
      allow list: if isAuthenticated();
      
      // Allow create if:
      // - User is authenticated
      // - User is the owner
      // - Log is for today or past (not future)
      // - Either completed or skipped (but not both)
      allow create: if isAuthenticated()
        && isOwner(request.resource.data.userId)
        && request.resource.data.date <= request.time
        && (request.resource.data.completed != request.resource.data.skipped)
        && request.resource.data.createdAt == request.time;
      
      // Allow update if:
      // - User is authenticated and is the owner
      // - Not changing logId, habitId, userId, or createdAt
      // - Log is for today (can't update past logs)
      allow update: if isAuthenticated()
        && isResourceOwner(resource)
        && request.resource.data.logId == resource.data.logId
        && request.resource.data.habitId == resource.data.habitId
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.createdAt == resource.data.createdAt
        && resource.data.date.toMillis() > (request.time.toMillis() - 86400000); // Within 24 hours
      
      // Allow delete if:
      // - User is authenticated and is the owner
      // - Log is for today (can't delete past logs)
      allow delete: if isAuthenticated() 
        && isResourceOwner(resource)
        && resource.data.date.toMillis() > (request.time.toMillis() - 86400000);
    }
    
    // ========================================================================
    // Friendships Collection
    // ========================================================================
    
    match /friendships/{friendshipId} {
      // Helper function to check if user is involved in friendship
      function isFriendshipMember() {
        return request.auth.uid == resource.data.userId || 
               request.auth.uid == resource.data.friendId;
      }
      
      // Allow read if:
      // - User is authenticated and is one of the friendship members
      allow read: if isAuthenticated() && isFriendshipMember();
      
      // Allow list (queries) if authenticated
      // Users will only see their own friendships due to query filters
      allow list: if isAuthenticated();
      
      // Allow create if:
      // - User is authenticated and is the requester (userId OR friendId)
      // - This allows both sending requests and accepting invitations
      allow create: if isAuthenticated() && (
        request.auth.uid == request.resource.data.userId ||
        request.auth.uid == request.resource.data.friendId
      );
      
      // Allow update if:
      // - User is authenticated and is one of the friendship members
      // - Typically used to accept/reject requests
      allow update: if isAuthenticated() && isFriendshipMember();
      
      // Allow delete if:
      // - User is authenticated and is one of the friendship members
      allow delete: if isAuthenticated() && isFriendshipMember();
    }
    
    // ========================================================================
    // Shared Habits Collection
    // ========================================================================
    
    match /shared_habits/{sharedHabitId} {
      // Helper function to check if user is a participant
      function isParticipant() {
        return request.auth.uid in resource.data.participants;
      }
      
      // Allow read if:
      // - User is authenticated and is a participant
      allow read: if isAuthenticated() && isParticipant();
      
      // Allow list if authenticated
      allow list: if isAuthenticated();
      
      // Allow create if:
      // - User is authenticated
      // - User is the owner (participants array contains user ID)
      allow create: if isAuthenticated()
        && request.auth.uid in request.resource.data.participants
        && request.resource.data.createdAt == request.time;
      
      // Allow update if:
      // - User is authenticated and is a participant
      allow update: if isAuthenticated()
        && request.auth.uid in resource.data.participants;
      
      // Allow delete if:
      // - User is authenticated and is a participant (owner check should be done in app)
      allow delete: if isAuthenticated()
        && request.auth.uid in resource.data.participants;
    }
    
    // ========================================================================
    // Achievements Collection
    // ========================================================================
    
    match /achievements/{achievementId} {
      // Allow read if:
      // - User is authenticated (achievements are public)
      allow read: if isAuthenticated();
      
      // Allow list if authenticated
      allow list: if isAuthenticated();
      
      // Allow create if:
      // - User is authenticated
      // - User is the owner (using userId field)
      allow create: if isAuthenticated()
        && request.auth.uid == request.resource.data.userId;
      
      // Allow update if:
      // - User is authenticated and is the owner
      allow update: if isAuthenticated()
        && request.auth.uid == resource.data.userId;
      
      // Allow delete if:
      // - User is authenticated and is the owner
      allow delete: if isAuthenticated()
        && request.auth.uid == resource.data.userId;
    }
    
    // ========================================================================
    // Habit Logs Collection
    // ========================================================================
    
    match /habit_logs/{logId} {
      // Allow read if:
      // - User is authenticated and is the owner of the log
      allow read: if isAuthenticated()
        && request.auth.uid == resource.data.userId;
      
      // Allow create if:
      // - User is authenticated and creating their own log
      allow create: if isAuthenticated()
        && request.auth.uid == request.resource.data.userId
        && request.resource.data.habitId is string
        && request.resource.data.habitId.size() > 0;
      
      // Allow update if:
      // - User is authenticated and is the owner
      allow update: if isAuthenticated()
        && request.auth.uid == resource.data.userId
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.habitId == resource.data.habitId;
      
      // Allow delete if:
      // - User is authenticated and is the owner
      allow delete: if isAuthenticated()
        && request.auth.uid == resource.data.userId;
    }
    
    // ========================================================================
    // Streak Recoveries Collection
    // ========================================================================
    
    match /streak_recoveries/{recoveryId} {
      // Allow read if:
      // - User is authenticated and is the owner of the recovery
      allow read: if isAuthenticated()
        && request.auth.uid == resource.data.userId;
      
      // Allow create if:
      // - User is authenticated and creating their own recovery
      allow create: if isAuthenticated()
        && request.auth.uid == request.resource.data.userId
        && request.resource.data.habitId is string
        && request.resource.data.habitId.size() > 0;
      
      // Allow update if:
      // - User is authenticated and is the owner
      allow update: if isAuthenticated()
        && request.auth.uid == resource.data.userId
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.habitId == resource.data.habitId;
      
      // Allow delete if:
      // - User is authenticated and is the owner
      allow delete: if isAuthenticated()
        && request.auth.uid == resource.data.userId;
    }
    
    // ========================================================================
    // Notifications Collection
    // ========================================================================
    
    match /notifications/{notificationId} {
      // Allow read if:
      // - User is authenticated and is the recipient
      allow read: if isAuthenticated() 
        && isOwner(resource.data.recipientId);
      
      // Allow create if:
      // - User is authenticated (sender)
      // - Not creating notification for themselves
      allow create: if isAuthenticated()
        && request.resource.data.senderId == request.auth.uid
        && request.resource.data.senderId != request.resource.data.recipientId
        && request.resource.data.createdAt == request.time;
      
      // Allow update if:
      // - User is authenticated and is the recipient
      // - Only updating 'read' field
      allow update: if isAuthenticated()
        && isOwner(resource.data.recipientId)
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']);
      
      // Allow delete if:
      // - User is authenticated and is the recipient
      allow delete: if isAuthenticated() && isOwner(resource.data.recipientId);
    }
    
    // ========================================================================
    // Default: Deny all other access
    // ========================================================================
    
    match /{document=**} {
      allow read, write: if false;
    }
  }
}